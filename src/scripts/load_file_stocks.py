"""
Read local stock configuration, pull Tiingo price data, and expose it as a tidy DataFrame.

For each ticker listed in `stock_data.json`, daily price data is fetched from Tiingo using the
historical start date and trade simulation end date defined in `date_ranges.json`.

The DataFrame contains one row per ticker with the following columns:
  * historical_data_start – ISO formatted start date from `date_ranges.json`
  * category – key from `stock_data.json`
  * ticker – individual ticker symbol for the category
  * trade_simulation_end – ISO formatted trade simulation end date
  * price_data_path – CSV path generated by the Tiingo fetch (None when unavailable)
  * fetch_error – Error message when a fetch fails (None on success)
"""

from __future__ import annotations

import json
from datetime import date
from pathlib import Path
from typing import Dict, MutableMapping, Optional

import pandas as pd

from scripts.fetch_tiingo_price_data import fetch_stock_data as fetch_tiingo_prices

DATA_DIR = Path(__file__).resolve().parent.parent / "data"
STOCK_DATA_FILE = DATA_DIR / "stock_data.json"
DATE_RANGES_FILE = DATA_DIR / "date_ranges.json"


def _load_json(path: Path) -> MutableMapping[str, object]:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def _parse_date(date_str: Optional[str]) -> Optional[date]:
    if not date_str:
        return None
    return date.fromisoformat(date_str)


def load_stock_dataframe(
    *,
    fetch_prices: bool = True,
    api_token: Optional[str] = None,
    output_dir: Optional[Path] = None,
) -> pd.DataFrame:
    if not STOCK_DATA_FILE.exists():
        raise FileNotFoundError(f"Stock data file not found: {STOCK_DATA_FILE}")
    if not DATE_RANGES_FILE.exists():
        raise FileNotFoundError(f"Date ranges file not found: {DATE_RANGES_FILE}")

    stock_payload = _load_json(STOCK_DATA_FILE)
    date_ranges = _load_json(DATE_RANGES_FILE)
    historical_start = _parse_date(date_ranges.get("historical_start"))
    simulation_end = None
    if isinstance(date_ranges.get("trade_simulation_window"), dict):
        simulation_end = _parse_date(date_ranges["trade_simulation_window"].get("end"))

    if not isinstance(stock_payload, dict):
        raise ValueError("Expected stock_data.json to contain a JSON object.")

    rows = []
    iso_start = historical_start.isoformat() if historical_start else None
    iso_sim_end = simulation_end.isoformat() if simulation_end else None

    for category, tickers in stock_payload.items():
        if not isinstance(tickers, list):
            raise ValueError(f"Expected list of tickers for category '{category}'.")
        for ticker in tickers:
            price_path = None
            fetch_error = None
            if fetch_prices and iso_start and iso_sim_end:
                try:
                    csv_path = fetch_tiingo_prices(
                        start_date=iso_start,
                        end_date=iso_sim_end,
                        ticker=str(ticker),
                        category=str(category),
                        api_token=api_token,
                        output_dir=output_dir,
                    )
                    price_path = str(csv_path)
                except Exception as exc:
                    fetch_error = str(exc)

            rows.append(
                {
                    "historical_data_start": iso_start,
                    "category": str(category),
                    "ticker": str(ticker),
                    "trade_simulation_end": iso_sim_end,
                    "price_data_path": price_path,
                    "fetch_error": fetch_error,
                }
            )

    return pd.DataFrame(
        rows,
        columns=[
            "historical_data_start",
            "category",
            "ticker",
            "trade_simulation_end",
            "price_data_path",
            "fetch_error",
        ],
    )


def main() -> None:
    dataframe = load_stock_dataframe()
    if dataframe.empty:
        print("No tickers found in stock_data.json")
    else:
        with pd.option_context("display.max_rows", None, "display.max_columns", None):
            print(dataframe.to_string(index=False))


if __name__ == "__main__":
    main()
